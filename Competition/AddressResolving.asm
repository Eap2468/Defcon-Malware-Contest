.code
GetModuleBaseAddress proc
	; Pointer to module string
	mov rdi, rcx
	; Get PEB
	mov rax, gs:[60h]
	; random debugging check
	cmp byte ptr [rax + 2h], 1
	je Exit_Debugged

	; PEB->Ldr->InLoadOrderModuleList
	mov rax, [rax + 18h]
	mov rax, [rax + 10h]

Setup_String:
	mov rax, [rax]
	mov rsi, rdi
	mov rbx, [rax + 60h]
	cmp rbx, 0
	je Not_Found

Check_String:
	mov cl, byte ptr [rsi]
	cmp cl, byte ptr [rbx]
	jne Setup_String
	cmp byte ptr [rbx], 0
	je Found_Module
	; Module names are stored in utf-8 format in the Ldr
	; so you have to increase the address by two instead of one
	inc rsi
	inc rbx
	inc rbx
	jmp Check_String

Found_Module:
	mov rax, [rax + 30h]
	ret

Not_Found:
	xor rax, rax
	ret

Exit_Debugged:
	mov rax, -1
	ret
GetModuleBaseAddress endp

GetFuncAddress proc
	; Module Address
	mov rdi, rcx
	; Function name
	mov r9, rdx

	; Establish stack frame
	push rbp
	mov rbp, rsp
	add rsp, 20h

	; DOS->NT->OPTIONAL->IMAGE_DIRECTORY_ENTRY_EXPORT
	xor rax, rax
	mov ax, word ptr [rdi + 3ch]
	add rax, rdi
	add rax, 18h
	mov eax, dword ptr [rax + 70h]

	; IMAGE_EXPORT_DIRECTORY
	lea rax, [rdi + rax]
	; AddressOfFunctions
	mov ecx, dword ptr [rax + 1ch]
	add rcx, rdi
	mov [rbp - 18h], rcx
	; AddressOfNames
	mov ecx, dword ptr [rax + 20h]
	add rcx, rdi
	mov [rbp - 10h], rcx
	; AddressOfNameOrdinals
	mov ecx, dword ptr [rax + 24h]
	add rcx, rdi
	mov [rbp - 8h], rcx

	; NumberOfNames for loop
	xor rcx, rcx
	mov ecx, dword ptr [rax + 18h]
	dec rcx

Setup_Check:
	; Function name offset
	mov rbx, [rbp - 10h]
	; Get correct value with iterator * sizeof(DWORD)
	mov r10, rcx
	imul r10, 4
	; Get the string address
	add r10, rbx
	xor rdx, rdx
	mov edx, dword ptr [r10]
	add rdx, rdi
	mov r10, rdx
	; Setup the compare string
	mov r8, r9

Compare_Function_Name:
	mov sil, byte ptr [r8]
	cmp sil, byte ptr [rdx]
	jne Iterate
	cmp sil, 0
	je Found_Function
	inc r8
	inc rdx
	jmp Compare_Function_Name

Iterate:
	dec rcx
	jmp Setup_Check

Found_Function:
	; Get function ordial from name
	imul rcx, 2
	mov r9, [rbp - 8h]
	add r9, rcx
	xor rdx, rdx
	mov dx, word ptr [r9]
	imul dx, 4
	; Get function offset from function addresses
	mov rax, [rbp - 18h]
	mov eax, dword ptr [rax + rdx]
	add rax, rdi
	; Get function address and cleanup function
	sub rsp, 20h
	pop rbp
	ret
GetFuncAddress endp

GetSyscallNumber proc
	xor rax, rax
Check:
	mov al, byte ptr [rcx]
	cmp al, 0b8h
	je Found
	cmp al, 0fh
	je Possible_Syscall
	cmp al, 0cdh
	je Possible_Interupt
	inc rcx
	jmp Check

Possible_Syscall:
	mov al, byte ptr [rcx + 1]
	cmp al, 5h
	je Exit_Error
	inc rcx
	jmp Check

Possible_Interupt:
	mov al, byte ptr [rcx + 1]
	cmp al, 23h
	je Exit_Error
	inc rcx
	jmp Check

Exit_Error:
	xor eax, eax
	dec eax
	ret

Found:
	inc rcx
	mov eax, dword ptr [rcx]
	ret
GetSyscallNumber endp

LoadSyscall proc
	mov rbx, rcx
	ret
LoadSyscall endp

ExecuteSyscall proc
	mov r10, rcx
	mov rax, rbx
	syscall
	ret
ExecuteSyscall endp
end