#include "String.h"

#define max(a,b) a > b ? a : b

char* strstr_custom(const char* one, const char* two)
{
	int one_len = strlen_custom(one);
	int two_len = strlen_custom(two);

	if (one_len == 0 || two_len == 0)
		return 0;

	if (one_len > two_len)
	{
		for (int i = 0; i < one_len; i++)
		{
			if (strcmp_custom(one + i, two_len, two) == 0)
			{
				return (char*)(one + i);
			}
		}
	}
	else
	{
		for (int i = 0; i < two_len; i++)
		{
			if (strcmp_custom(one, one_len, two + i) == 0)
			{
				return (char*)(two + i);
			}
		}
	}
	return 0;
}

wchar_t* wstrstr_custom(const wchar_t* one, const wchar_t* two)
{
	int one_len = wstrlen_custom(one);
	int two_len = wstrlen_custom(two);

	if (one_len == 0 || two_len == 0)
		return 0;

	if (one_len > two_len)
	{
		for (int i = 0; i < one_len; i++)
		{
			if (wstrcmp_custom(one + i, two_len, two) == 0)
			{
				return (wchar_t*)(one + i);
			}
		}
	}
	else
	{
		for (int i = 0; i < two_len; i++)
		{
			if (wstrcmp_custom(one, one_len, two + i) == 0)
			{
				return (wchar_t*)(two + i);
			}
		}
	}
	return 0;
}

char* strcat_custom(const char* front, const char* back)
{
	NTSTATUS status = 0;
	SIZE_T new_len = 0;
	int front_len = 0;
	int back_len = 0;
	char* new_str = 0;

	front_len = strlen_custom(front);
	back_len = strlen_custom(back);

	if (front_len == 0 || back_len == 0)
		return 0;

	new_len = (SIZE_T)front_len;
	new_len += back_len;

	status = NT::NtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&new_str, 0, &new_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
		return 0;

	memcpy_custom(new_str, (void*)front, front_len);
	memcpy_custom(new_str + front_len, (void*)back, back_len);

	return new_str;
}

wchar_t* wstrcat_custom(const wchar_t* front, const wchar_t* back)
{
	NTSTATUS status = 0;
	SIZE_T new_len = 0;
	int front_len = 0;
	int back_len = 0;
	wchar_t* new_str = 0;

	front_len = wstrlen_custom(front);
	back_len = wstrlen_custom(back);

	if (front_len == 0 || back_len == 0)
		return 0;

	new_len = (SIZE_T)(front_len * 2);
	new_len += back_len * 2;

	status = NT::NtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&new_str, 0, &new_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
		return 0;

	memcpy_custom(new_str, (void*)front, front_len * 2);
	memcpy_custom(new_str + front_len, (void*)back, back_len * 2);

	return new_str;
}

wchar_t* wstrdup_custom(const wchar_t* str)
{
	NTSTATUS status = 0;
	SIZE_T len = 0;
	wchar_t* new_str = 0;

	len = (SIZE_T)(wstrlen_custom(str) * 2);

	status = NT::NtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&new_str, 0, &len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
		return 0;

	memcpy_custom(new_str, (void*)str, (int)len);

	return new_str;
}

void AnsiStringToUniString(const char* str, PWSTR* wstr)
{
	NTSTATUS status = 0;
	uintptr_t ntdll = 0;
	SIZE_T RegionSize = 0;
	unsigned long len = 0;
	wchar_t* wstr_addy = 0;

	len = strlen_custom(str);
	RegionSize = (SIZE_T)(len * 2);
	status = NT::NtAllocateVirtualMemory((HANDLE)-1, (PVOID*)&wstr_addy, 0, &RegionSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (status != STATUS_SUCCESS)
	{
		*wstr = 0;
		return;
	}

	for (int i = 0; i < len; i++)
	{
		wstr_addy[i] = str[i];
	}
	*wstr = wstr_addy;
}

char* strdecrypt(const char* text)
{
	char* str = (char*)text;
	int len = strlen_custom(str);
	for (int i = 0; i < len; i++)
	{
		str[i] = str[i] ^ 0x24;
	}
	return str;
}

wchar_t* wstrdecrypt(const wchar_t* text)
{
	wchar_t* str = (wchar_t*)text;
	int len = wstrlen_custom(str);
	for (int i = 0; i < len; i++)
	{
		str[i] = str[i] ^ 0x24;
	}
	return str;
}

int HexToBytes(const char* src, int len, char* dest)
{
	int di = 0;
	for (int i = 0; i < len - 1; i += 2)
	{
		if (src[i] <= 0x39)
		{
			dest[di] = src[i] - 0x30;
			dest[di] <<= 4;
		}
		else
		{
			dest[di] = src[i] - 0x57;
			dest[di] <<= 4;
		}

		if (src[i + 1] <= 0x39)
			dest[di] += src[i + 1] - 0x30;
		else
			dest[di] += src[i + 1] - 0x57;
		di++;
	}

	return di + 1;
}

wchar_t* wmatch(wchar_t* dst, wchar_t* target)
{
	for (int i = 0; i < wstrlen_custom(target); i++)
	{
		if (wstrcmp_custom(target, wstrlen_custom(target), dst) == 0)
		{
			return dst + i;
		}
	}
	return 0;
}

void UniStringToAnsiString(char* dst, const wchar_t* src)
{
	for (int i = 0; i < wstrlen_custom(src); i++)
	{
		dst[i] = src[i];
	}
}